<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>What Am I Drawing?</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 1400px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            color: white;
        }

        h1 {
            color: white;
            margin-bottom: 10px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            color: rgba(255,255,255,0.9);
            font-size: 1.2rem;
        }

        /* Main Menu Styles */
        .main-menu {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .main-menu {
                grid-template-columns: 1fr;
            }
        }

        .menu-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .menu-card h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #2c3e50;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #3498db;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
            transition: all 0.3s;
            width: 100%;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .btn-primary:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Rooms List */
        .rooms-list {
            max-height: 400px;
            margin: 15px 0;
            transition: all 0.3s ease;
        }

        .room-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            margin-bottom: 10px;
            background: #f8f9fa;
            transition: all 0.3s;
            max-width: 100%;
            transition: all 0.3s ease;
        }

        .room-item:hover {
            border-color: #3498db;
            transform: translateX(5px);
        }

        .room-info {
            flex: 1;
        }

        .room-name {
            font-weight: bold;
            color: #2c3e50;
            font-size: 1.1rem;
        }

        .room-details {
            font-size: 0.9rem;
            color: #6c757d;
            margin-top: 5px;
        }

        .room-language {
            display: inline-block;
            background: #3498db;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-top: 5px;
        }

        @keyframes pulseUpdate {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .btn-join {
            background: #27ae60;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }

        .btn-join:hover {
            background: #219a52;
        }

        .no-rooms {
            text-align: center;
            padding: 40px 20px;
            color: #6c757d;
            font-style: italic;
            background: #f8f9fa;
            border-radius: 10px;
            border: 2px dashed #dee2e6;
        }

        /* Game Area Styles */
        .game-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        @media (min-width: 1025px) {
            .game-area {
                flex-direction: row;
            }
            
            .drawing-section {
                flex: 2;
            }
            
            .game-area > div:last-child {
                flex: 1;
            }
        }

        .drawing-section {
            background-color: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .canvas-container {
            position: relative;
            margin-bottom: 15px;
            border: 3px solid #3498db;
            border-radius: 10px;
            background: white;
            overflow: hidden;
            
            /* Square aspect ratio */
            width: 100%;
            aspect-ratio: 1 / 1; /* This makes it square */
            max-width: 500px; /* Maximum size for large screens */
            
            /* Center the canvas */
            margin-left: auto;
            margin-right: auto;
            
            /* Prevent text selection */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: none;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .canvas-container {
                max-width: 95vw; /* Slightly smaller on mobile */
                margin: 0 auto 15px auto;
            }
        }

        /* Desktop optimizations */
        @media (min-width: 1024px) {
            .canvas-container {
                max-width: 500px; /* Comfortable size for desktop */
            }
        }

        #drawingCanvas {
            background-color: white;
            cursor: crosshair;
            
            /* Fill the container */
            width: 100% !important;
            height: 100% !important;
            
            /* Touch handling */
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        .tools {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
            justify-content: center;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #e9ecef;
            width: 100%;
            max-width: 500px;
        }

        .tools-section {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: white;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            min-height: 50px;
        }

        .tools-section label {
            font-size: 0.9rem;
            font-weight: bold;
            color: #495057;
            white-space: nowrap;
        }

        /* Mobile tools adjustment */
        @media (max-width: 768px) {
            .tools {
                flex-wrap: wrap;
                justify-content: center;
                padding: 10px;
                gap: 10px;
            }
            
            .tools-section {
                margin: 0 5px;
            }
        }

        .color-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .color-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 3px solid #ddd;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }

        .color-btn:hover {
            transform: scale(1.1);
            border-color: #999;
        }

        .color-btn.active {
            border-color: #333;
            transform: scale(1.15);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .brush-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #brushSize {
            width: 100px;
        }

        .brush-size-value {
            font-size: 0.9rem;
            color: #6c757d;
            min-width: 25px;
            text-align: center;
            font-weight: bold;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .players-section {
            background-color: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }

        .players-list {
            margin: 20px 0 20px 0;
            max-height: 300px;
            overflow-y: auto;
        }

        .player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            border-bottom: 2px solid #f8f9fa;
            transition: background 0.3s;
        }

        .player :first-child {
            width: 50%;
        }

        .player:hover {
            background: #f8f9fa;
        }

        .player.current {
            background-color: #e8f4fc;
            border-left: 4px solid #3498db;
        }

        .player.drawing {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
        }

        .player.host::after {
            content: " ðŸ‘‘";
            width: 22px;
            text-align: center;
        }

        .player.guest::after {
            content: " ðŸ‘¤";
            width: 22px;
            text-align: center;
        }

        .chat-section {
            background-color: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            height: fit-content;
            margin-bottom: 20px;
        }

        .chat-messages {
            height: 300px;
            overflow-y: auto;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            background-color: #f9f9f9;
        }

        .message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 8px;
        }

        .message.system {
            background: #e9ecef;
            color: #6c757d;
            font-style: italic;
            text-align: center;
            border-left: 4px solid #6c757d;
        }

        .message.game-ended {
            background: #fff3cd;
            color: #856404;
            font-weight: bold;
            border-left: 4px solid #ffc107;
            text-align: center;
        }

        .message.correct {
            background: #d4edda;
            color: #155724;
            font-weight: bold;
            border-left: 4px solid #28a745;
        }

        .message.player {
            background: white;
            border-left: 4px solid #3498db;
        }

        .chat-input {
            display: flex;
            gap: 10px;
        }

        #messageInput {
            flex: 1;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1rem;
            width: 150px;
        }

        #messageInput:focus {
            outline: none;
            border-color: #3498db;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .timer {
            font-size: 2rem;
            font-weight: bold;
            color: #e74c3c;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            min-width: 60px;
        }

        .score {
            font-size: 1.3rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .word-to-draw {
            font-size: 1.5rem;
            text-align: center;
            margin: 15px 0;
            color: #3498db;
            font-weight: bold;
            min-height: 40px;
            padding: 10px;
            background: #e8f4fc;
            border-radius: 8px;
            border: 2px dashed #3498db;
            width: 100%;
            max-width: 500px;
        }

        .hidden {
            display: none !important;
        }

        .winner-section {
            text-align: center;
            padding: 40px;
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
            border-radius: 15px;
            margin-top: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }

        .winner-section h2 {
            font-size: 2.5rem;
            margin-bottom: 20px;
        }

        .winner-section p {
            font-size: 1.3rem;
            margin-bottom: 30px;
        }

        /* Join Room Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            width: 90%;
            max-width: 400px;
        }

        .modal h3 {
            margin-bottom: 20px;
            color: #2c3e50;
            text-align: center;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-actions button {
            flex: 1;
        }

        .btn-cancel {
            background: #95a5a6;
        }

        .btn-cancel:hover {
            background: #7f8c8d;
        }

        /* Room Status Badges */
        .room-status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 10px;
        }

        .status-waiting {
            background: #d4edda;
            color: #155724;
        }

        .status-playing {
            background: #fff3cd;
            color: #856404;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* Room Statistics */
        .room-statistics {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transition: all 0.3s ease;
        }

        .room-statistics .stat-item {
            padding: 10px;
            transition: transform 0.3s ease;
        }

        .room-statistics .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
            transition: all 0.3s ease;
        }

        .room-statistics .stat-label {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        /* No Rooms Message Styles */
        .no-rooms {
            text-align: center;
            padding: 40px 20px;
            color: #6c757d;
            font-style: italic;
            background: #f8f9fa;
            border-radius: 10px;
            border: 2px dashed #dee2e6;
            transition: all 0.3s ease;
        }

        .no-rooms:hover {
            border-color: #3498db;
            background: #e8f4fc;
        }

        /* Room List Animation */
        .room-item {
            transition: all 0.3s ease;
        }

        .rooms-list {
            transition: all 0.3s ease;
            min-height: 100px;
        }

        /* Connection Status */
        #connectionStatus {
            position: relative;
            display: block;
            padding: 15px;
            background: white;
            border-radius: 5px;
            font-size: 16px;
            width: 100%;
            font-weight: bold;
            border-radius: 15px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>What Am I Drawing?</h1>
            <p class="subtitle">Draw and guess words together with your friends in real time!</p>
        </header>

        <!-- Connection status -->
        <div id="connectionStatus" style="color: orange;">ðŸŸ  Connecting ...</div>
        
        <!-- Main Menu -->
        <div id="mainMenu">
            <div class="main-menu">
                <!-- Create Room Card -->
                <div class="menu-card">
                    <h2>Create New Room</h2>
                    <div class="form-group">
                        <label for="createPlayerName">Your Name:</label>
                        <input type="text" id="createPlayerName" placeholder="Enter your name" maxlength="20">
                    </div>
                    <div class="form-group">
                        <label for="roomName">Room Name:</label>
                        <input type="text" id="roomName" placeholder="Enter room name" maxlength="30">
                    </div>
                    <div class="form-group">
                        <label for="roomLanguage">Room Language:</label>
                        <select id="roomLanguage">
                            <option value="en">English</option>
                            <option value="sv">Svenska</option>
                        </select>
                    </div>
                    <button id="createRoomBtn" class="btn-primary">Create New Room</button>
                </div>
                
                <!-- Available Rooms Card -->
                <div class="menu-card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h2>Available Rooms</h2>
                    </div>
                    
                    <!-- Statistics display - ALWAYS VISIBLE -->
                    <div id="roomStatistics" class="room-statistics" style="
                        background: #f8f9fa;
                        border-radius: 10px;
                        padding: 15px;
                        margin-bottom: 15px;
                        border: 2px solid #e9ecef;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; text-align: center;">
                        <div class="stat-item">
                            <div class="stat-value" style="font-size: 1.5rem; font-weight: bold; color: #3498db;">0</div>
                            <div class="stat-label" style="font-size: 0.8rem; color: #6c757d;">Total Rooms</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" style="font-size: 1.5rem; font-weight: bold; color: #27ae60;">0</div>
                            <div class="stat-label" style="font-size: 0.8rem; color: #6c757d;">Waiting</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" style="font-size: 1.5rem; font-weight: bold; color: #f39c12;">0</div>
                            <div class="stat-label" style="font-size: 0.8rem; color: #6c757d;">Playing</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" style="font-size: 1.5rem; font-weight: bold; color: #e74c3c;">0</div>
                            <div class="stat-label" style="font-size: 0.8rem; color: #6c757d;">Finished</div>
                        </div>
                        </div>
                    </div>
                    
                    <div id="roomsList" class="rooms-list">
                        <div id="noRoomsMessage" class="no-rooms" style="display: block;">
                        <div style="font-size: 1.2rem; margin-bottom: 10px; color: #6c757d;">ðŸŽ¨ No rooms available</div>
                        <div style="font-size: 0.9rem; color: #8fa0ad;">
                            Create a new room to start playing with friends!
                        </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Game Area -->
        <div id="gameArea" class="hidden">
            <div class="game-info">
                <div id="roomInfo" class="score"></div>
                <div id="timer" class="timer">60</div>
                <div id="yourScore" class="score">Your score: 0</div>
            </div>
            
            <div class="game-area">
                <!-- Left Column: Drawing Area -->
                <div class="drawing-section">
                    <h2>Drawing Area</h2>
                    <div id="wordToDraw" class="word-to-draw"></div>
                    <div class="canvas-container">
                        <canvas id="drawingCanvas"></canvas>
                    </div>
                    <div class="tools">
                        <div class="tools-section">
                            <label>Color:</label>
                            <div class="color-buttons">
                                <div class="color-btn active" style="background-color: #000000;" data-color="#000000" title="Black"></div>
                                <div class="color-btn" style="background-color: #ff0000;" data-color="#ff0000" title="Red"></div>
                                <div class="color-btn" style="background-color: #0000ff;" data-color="#0000ff" title="Blue"></div>
                                <div class="color-btn" style="background-color: #008000;" data-color="#008000" title="Green"></div>
                                <div class="color-btn" style="background-color: #ffa500;" data-color="#ffa500" title="Orange"></div>
                                <div class="color-btn" style="background-color: #800080;" data-color="#800080" title="Purple"></div>
                                <div class="color-btn" style="background-color: #ffffff; border: 2px solid #333;" data-color="#ffffff" title="Eraser"></div>
                            </div>
                        </div>
                        <div class="tools-section">
                            <label>Size:</label>
                            <div class="brush-controls">
                                <input type="range" id="brushSize" min="1" max="50" value="5">
                                <span id="brushSizeValue" class="brush-size-value">5</span>
                            </div>
                        </div>
                        <div class="tools-section">
                            <div class="action-buttons">
                                <button id="clearCanvasBtn" class="btn-secondary">Clear</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Right Column: Chat and Players -->
                <div>
                    <!-- Chat Section -->
                    <div class="chat-section">
                        <h2>Guess Chat</h2>
                        <div id="chatMessages" class="chat-messages"></div>
                        <div class="chat-input">
                            <input type="text" id="messageInput" placeholder="Type your guess here...">
                            <button id="sendMessageBtn" class="btn-primary">Send</button>
                        </div>
                    </div>

                    <!-- Players Section -->
                    <div class="players-section">
                        <h2>Players in Room</h2>
                        <div id="playersList" class="players-list"></div>
                        <div class="action-buttons">
                            <button id="startGameBtn" class="btn-primary">Start Game</button>
                            <button id="leaveRoomBtn" class="btn-secondary">Leave Room</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Winner Section -->
        <div id="winnerSection" class="winner-section hidden">
            <h2 id="congratulationsText">Congratulations!</h2>
            <p id="winnerMessage"></p>
            <div class="action-buttons">
                <button id="backToLobbyBtn" class="btn-primary">Back to Lobby</button>
            </div>
        </div>
    </div>

    <!-- Join Room Modal -->
    <div id="joinRoomModal" class="modal">
        <div class="modal-content">
            <h3>Join Room</h3>
            <div class="form-group">
                <label for="joinPlayerName">Enter your name:</label>
                <input type="text" id="joinPlayerName" placeholder="Your name" maxlength="20">
            </div>
            <div class="modal-actions">
                <button id="confirmJoinBtn" class="btn-primary">Join</button>
                <button id="cancelJoinBtn" class="btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Socket.IO Client Library -->
    <script src="socket.io/socket.io.js"></script>
    <script>
        // Game state
        const gameState = {
            socket: null,
            currentRoom: null,
            currentPlayer: null,
            players: [],
            isDrawing: false,
            isHost: false,
            gameStarted: false,
            currentLanguage: 'en',
            selectedRoomId: null,
            roomStatistics: {
                total: 0,
                waiting: 0,
                playing: 0,
                finished: 0
            }
        };

        // Canvas state
        const canvasState = {
            ctx: null,
            isDrawing: false,
            lastX: 0,
            lastY: 0,
            currentColor: '#000000',
            currentBrushSize: 5,
            canvasInitialized: false,
            usingTouch: false,
            lastSent: 0,
            sendDelay: 100,
            isSending: false
        };

        // DOM Elements cache
        let elements = {};

        // Initialize the game
        function init() {
            initializeDOMElements();
            setupSocket();
            setupEventListeners();
            updateUI();
        }

        // Initialize all DOM elements
        function initializeDOMElements() {
            elements = {
                // Main menu
                mainMenu: document.getElementById('mainMenu'),
                gameArea: document.getElementById('gameArea'),
                winnerSection: document.getElementById('winnerSection'),
                
                // Create room
                createPlayerName: document.getElementById('createPlayerName'),
                roomName: document.getElementById('roomName'),
                roomLanguage: document.getElementById('roomLanguage'),
                createRoomBtn: document.getElementById('createRoomBtn'),
                
                // Rooms list
                roomsList: document.getElementById('roomsList'),
                roomStatistics: document.getElementById('roomStatistics'),
                
                // Game area
                roomInfo: document.getElementById('roomInfo'),
                timer: document.getElementById('timer'),
                yourScore: document.getElementById('yourScore'),
                wordToDraw: document.getElementById('wordToDraw'),
                drawingCanvas: document.getElementById('drawingCanvas'),
                clearCanvasBtn: document.getElementById('clearCanvasBtn'),
                playersList: document.getElementById('playersList'),
                startGameBtn: document.getElementById('startGameBtn'),
                leaveRoomBtn: document.getElementById('leaveRoomBtn'),
                chatMessages: document.getElementById('chatMessages'),
                messageInput: document.getElementById('messageInput'),
                sendMessageBtn: document.getElementById('sendMessageBtn'),
                
                // Winner section
                congratulationsText: document.getElementById('congratulationsText'),
                winnerMessage: document.getElementById('winnerMessage'),
                backToLobbyBtn: document.getElementById('backToLobbyBtn'),
                
                // Join room modal
                joinRoomModal: document.getElementById('joinRoomModal'),
                joinPlayerName: document.getElementById('joinPlayerName'),
                confirmJoinBtn: document.getElementById('confirmJoinBtn'),
                cancelJoinBtn: document.getElementById('cancelJoinBtn'),
                
                // Canvas tools
                brushSize: document.getElementById('brushSize'),
                brushSizeValue: document.getElementById('brushSizeValue')
            };
        }

        // Setup Socket.IO connection
        function setupSocket() {
            const socketOptions = {
                // Force polling or specify transport preference
                transports: ['polling'], // Use only polling
                upgrade: false,
                forceNew: true,
                timeout: 10000,
                reconnection: true,
                reconnectionAttempts: Infinity,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000
            };

            if(window.location.hostname !== 'localhost') {
                gameState.socket = io({
                    path: '/what-am-i-drawing/socket.io'
                });
            } else {
                gameState.socket = io(socketOptions);
            }

            // Enhanced connection handling
            gameState.socket.on('connect', () => {
                console.log('Connected to server');
                updateConnectionStatus(true);
            });

            gameState.socket.on('disconnect', (reason) => {
                console.log('Disconnected from server:', reason);
                updateConnectionStatus(false);
                
                if (reason === 'io server disconnect') {
                    gameState.socket.connect();
                }
            });

            gameState.socket.on('connect_error', (error) => {
                console.log('Connection error:', error);
                updateConnectionStatus(false);
            });

            gameState.socket.on('reconnect', (attemptNumber) => {
                console.log('Reconnected after', attemptNumber, 'attempts');
                updateConnectionStatus(true);
            });

            // Game event listeners
            gameState.socket.on('room_created', handleRoomCreated);
            gameState.socket.on('room_joined', handleRoomJoined);
            gameState.socket.on('room_list_updated', handleRoomListUpdated);
            gameState.socket.on('player_joined', handlePlayerJoined);
            gameState.socket.on('player_left', handlePlayerLeft);
            gameState.socket.on('game_started', handleGameStarted);
            gameState.socket.on('game_reset', handleGameReset);
            gameState.socket.on('new_round', handleNewRound);
            gameState.socket.on('round_ended', handleRoundEnded);
            gameState.socket.on('correct_guess', handleCorrectGuess);
            gameState.socket.on('timer_update', handleTimerUpdate);
            gameState.socket.on('game_ended', handleGameEnded);
            gameState.socket.on('chat_message', handleChatMessage);
            gameState.socket.on('canvas_updated', handleCanvasUpdated);
            gameState.socket.on('chat_history', handleChatHistory);
            gameState.socket.on('error', handleError);
            gameState.socket.on('left_room', handleLeftRoom);
        }

        function updateConnectionStatus(connected) {
            let statusElement = document.getElementById('connectionStatus');
            if (!statusElement) {
                statusElement = document.createElement('div');
                statusElement.id = 'connectionStatus';
                document.body.appendChild(statusElement);
            }
            statusElement.textContent = connected ? 'ðŸŸ¢ Connected' : 'ðŸ”´ Disconnected';
            statusElement.style.color = connected ? 'green' : 'red';
        }

        // Setup event listeners
        function setupEventListeners() {
            // Main menu
            if (elements.createRoomBtn) {
                elements.createRoomBtn.addEventListener('click', createRoom);
            }

            // Game controls
            if (elements.startGameBtn) {
                elements.startGameBtn.addEventListener('click', startGame);
            }
            
            if (elements.leaveRoomBtn) {
                elements.leaveRoomBtn.addEventListener('click', leaveRoom);
            }
            
            if (elements.sendMessageBtn) {
                elements.sendMessageBtn.addEventListener('click', sendMessage);
            }
            
            if (elements.messageInput) {
                elements.messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') sendMessage();
                });
            }

            // Canvas tools
            if (elements.clearCanvasBtn) {
                elements.clearCanvasBtn.addEventListener('click', clearCanvas);
            }
            
            // Color buttons
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('color-btn')) {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    canvasState.currentColor = e.target.dataset.color;
                    if (canvasState.ctx) {
                        canvasState.ctx.strokeStyle = canvasState.currentColor;
                    }
                }
            });

            // Brush size with scaling
            if (elements.brushSize && elements.brushSizeValue) {
                elements.brushSize.addEventListener('input', (e) => {
                    const baseSize = parseInt(e.target.value);
                    canvasState.currentBrushSize = baseSize;
                    elements.brushSizeValue.textContent = baseSize;
                    if (canvasState.ctx) {
                        canvasState.ctx.lineWidth = canvasState.currentBrushSize;
                    }
                });
            }

            // Winner section
            if (elements.backToLobbyBtn) {
                elements.backToLobbyBtn.addEventListener('click', backToLobby);
            }

            // Join room modal
            if (elements.confirmJoinBtn) {
                elements.confirmJoinBtn.addEventListener('click', confirmJoinRoom);
            }
            
            if (elements.cancelJoinBtn) {
                elements.cancelJoinBtn.addEventListener('click', hideJoinModal);
            }
        }

        // Setup canvas for drawing with square aspect ratio
        function setupCanvas() {
            if (!elements.drawingCanvas) {
                console.error('Canvas element not found');
                return;
            }

            const canvas = elements.drawingCanvas;
            canvasState.ctx = canvas.getContext('2d');
            
            // Fixed internal resolution for consistent drawing
            const INTERNAL_SIZE = 512;
            
            const initializeCanvas = () => {
                const container = canvas.parentElement;
                if (!container) return;
                
                const displaySize = Math.min(container.clientWidth, container.clientHeight);
                
                // Set internal resolution (for drawing)
                canvas.width = INTERNAL_SIZE;
                canvas.height = INTERNAL_SIZE;
                
                // Set display size (what users see)
                canvas.style.width = displaySize + 'px';
                canvas.style.height = displaySize + 'px';
                
                // Reset transform and set proper scaling
                canvasState.ctx.setTransform(1, 0, 0, 1, 0, 0);
                
                // Calculate scale factor
                const scale = INTERNAL_SIZE / displaySize;
                canvasState.ctx.scale(scale, scale);
                
                // Initialize canvas with white background
                canvasState.ctx.fillStyle = 'white';
                canvasState.ctx.fillRect(0, 0, displaySize, displaySize);
                
                // Set drawing properties
                canvasState.ctx.lineJoin = 'round';
                canvasState.ctx.lineCap = 'round';
                canvasState.ctx.lineWidth = canvasState.currentBrushSize;
                canvasState.ctx.strokeStyle = canvasState.currentColor;
                canvasState.canvasInitialized = true;
            };

            // Initialize canvas
            initializeCanvas();

            // Handle resize
            let lastContainerSize = 0;
            let resizeTimeout;
            window.addEventListener('resize', () => {
                if (!canvasState.canvasInitialized || !gameState.isDrawing) return;
                
                const container = elements.drawingCanvas.parentElement;
                const currentSize = Math.min(container.clientWidth, container.clientHeight);
                
                // Only resize if the size change is significant (more than 10 pixels)
                if (Math.abs(currentSize - lastContainerSize) < 10) return;
                
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // Save current canvas content
                    const currentCanvasData = elements.drawingCanvas.toDataURL();
                    
                    // Update canvas dimensions
                    elements.drawingCanvas.style.width = currentSize + 'px';
                    elements.drawingCanvas.style.height = currentSize + 'px';
                    
                    // Recalculate scale
                    const INTERNAL_SIZE = 512;
                    const scale = INTERNAL_SIZE / currentSize;
                    
                    canvasState.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    canvasState.ctx.scale(scale, scale);
                    
                    // Restore content
                    const img = new Image();
                    img.onload = function() {
                        canvasState.ctx.drawImage(img, 0, 0, currentSize, currentSize);
                    };
                    img.src = currentCanvasData;
                    
                    lastContainerSize = currentSize;
                }, 300); // Even longer delay for better performance
            });

            // Event listeners
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', handleMouseOut);

            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('touchcancel', handleTouchEnd);

            setupTouchPrevention();
        }

        function setupTouchPrevention() {
            const canvas = elements.drawingCanvas;
            
            document.addEventListener('touchstart', function(e) {
                if ((e.target === canvas || canvas.contains(e.target)) && gameState.isDrawing) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('touchmove', function(e) {
                if (canvasState.isDrawing && canvasState.usingTouch) {
                    e.preventDefault();
                }
            }, { passive: false });
        }

        function startDrawing(e) {
            if (!gameState.isDrawing || !canvasState.canvasInitialized) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            canvasState.isDrawing = true;
            const pos = getMousePos(e);
            [canvasState.lastX, canvasState.lastY] = [pos.x, pos.y];

            // Start with a dot
            canvasState.ctx.beginPath();
            canvasState.ctx.arc(canvasState.lastX, canvasState.lastY, canvasState.currentBrushSize / 2, 0, Math.PI * 2);
            canvasState.ctx.fillStyle = canvasState.currentColor;
            canvasState.ctx.fill();
            canvasState.ctx.beginPath();
        }

        // Drawing functions
        function draw(e) {
            if (!canvasState.isDrawing || !gameState.isDrawing || !canvasState.canvasInitialized) return;
            
            e.preventDefault();
            const pos = getMousePos(e);

            canvasState.ctx.beginPath();
            canvasState.ctx.moveTo(canvasState.lastX, canvasState.lastY);
            canvasState.ctx.lineTo(pos.x, pos.y);
            canvasState.ctx.strokeStyle = canvasState.currentColor;
            canvasState.ctx.lineWidth = canvasState.currentBrushSize;
            canvasState.ctx.stroke();
            
            [canvasState.lastX, canvasState.lastY] = [pos.x, pos.y];
            
            // Throttled canvas data sending
            sendCanvasDataThrottled();
        }

        function sendCanvasDataThrottled() {
            const now = Date.now();
            if (now - canvasState.lastSent < canvasState.sendDelay || canvasState.isSending) {
                return;
            }
            
            canvasState.lastSent = now;
            canvasState.isSending = true;
            
            requestAnimationFrame(() => {
                try {
                    const canvasData = getCanvasDataAtInternalResolution();
                    if (gameState.socket && gameState.socket.connected) {
                        gameState.socket.emit('update_canvas', { canvasData });
                    }
                } catch (error) {
                    console.error('Error sending canvas data:', error);
                } finally {
                    canvasState.isSending = false;
                }
            });
        }

        function getCanvasDataAtInternalResolution() {
            // Return compressed data at consistent resolution
            return elements.drawingCanvas.toDataURL('image/jpeg', 0.5);
        }

        function stopDrawing() {
            if (canvasState.isDrawing) {
                canvasState.isDrawing = false;
                canvasState.ctx.beginPath();
            }
        }

        function handleMouseOut(e) {
            if (!isTouchDevice()) {
                stopDrawing();
            }
        }

        function isTouchDevice() {
            return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        }

        function handleTouchStart(e) {
            if (!gameState.isDrawing) return;
            e.preventDefault();
            canvasState.usingTouch = true;
            
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY,
                bubbles: true,
                cancelable: true
            });
            elements.drawingCanvas.dispatchEvent(mouseEvent);
        }

        function handleTouchMove(e) {
            if (!gameState.isDrawing) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY,
                bubbles: true,
                cancelable: true
            });
            elements.drawingCanvas.dispatchEvent(mouseEvent);
        }

        function handleTouchEnd(e) {
            if (!gameState.isDrawing) return;
            e.preventDefault();
            canvasState.usingTouch = false;
            
            const mouseEvent = new MouseEvent('mouseup', {
                bubbles: true,
                cancelable: true
            });
            elements.drawingCanvas.dispatchEvent(mouseEvent);
        }

        function getMousePos(e) {
            const canvas = elements.drawingCanvas;
            const rect = canvas.getBoundingClientRect();
            
            let clientX, clientY;
            
            if (e.type.includes('touch')) {
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    return { x: 0, y: 0 };
                }
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            // Get position relative to canvas in display pixels
            const displayX = clientX - rect.left;
            const displayY = clientY - rect.top;
            
            // The canvas context is already scaled, so we use display coordinates directly
            // The scaling is handled by the canvas context transform
            return {
                x: Math.max(0, Math.min(rect.width, displayX)),
                y: Math.max(0, Math.min(rect.height, displayY))
            };
        }

        function clearCanvas() {
            if (!canvasState.ctx || !canvasState.canvasInitialized) return;
            
            const container = elements.drawingCanvas.parentElement;
            const displaySize = Math.min(container.clientWidth, container.clientHeight);
            
            canvasState.ctx.fillStyle = 'white';
            canvasState.ctx.fillRect(0, 0, displaySize, displaySize);
            gameState.socket.emit('clear_canvas', {});
        }

        // ... (rest of the JavaScript code remains the same as your original, including all the event handlers and UI functions)

        // Socket event handlers (keep all your existing handlers)
        function handleRoomCreated(data) {
            gameState.currentRoom = data.room;
            gameState.currentPlayer = data.player;
            gameState.players = data.players;
            gameState.isHost = true;
            gameState.currentLanguage = data.room.language;

            updateUI();
            showGameArea();
            updatePlayersList();
            addChatMessage('system', `${gameState.currentPlayer.name} joined the game`);
        }

        function handleRoomJoined(data) {
            gameState.currentRoom = data.room;
            gameState.currentPlayer = data.player;
            gameState.players = data.players;
            gameState.isHost = data.host === gameState.currentPlayer.id;
            gameState.currentLanguage = data.room.language;

            updateUI();
            showGameArea();
            updatePlayersList();
            addChatMessage('system', `${gameState.currentPlayer.name} joined the game`);
        }

        function handleRoomListUpdated(data) {
            updateRoomsList(data.rooms || []);
            if (data.statistics) {
                gameState.roomStatistics = data.statistics;
                updateRoomStatistics(data.statistics);
            } else {
                updateRoomStatistics({
                    total: 0,
                    waiting: 0,
                    playing: 0,
                    finished: 0
                });
            }
        }

        function handleChatHistory(data) {
            if (!elements.chatMessages) return;
            elements.chatMessages.innerHTML = '';
            data.messages.forEach(message => {
                addChatMessage(message.type || 'player', message.message, message.player);
            });
        }

        function handlePlayerJoined(data) {
            if (gameState.currentRoom && data.player && data.player.id) {
                gameState.players = data.players;
                gameState.isHost = data.host === gameState.currentPlayer.id;
                updatePlayersList();
                addChatMessage('system', `${data.player.name} joined the game`);
            }
        }

        function handlePlayerLeft(data) {
            if (gameState.currentRoom) {
                gameState.players = data.players;
                gameState.isHost = data.host === gameState.currentPlayer.id;
                updatePlayersList();
            }
        }

        function handleGameStarted(data) {
            gameState.gameStarted = true;
            gameState.gameState = data.gameState;
            updateUI();
        }

        function handleGameReset(data) {
            gameState.gameStarted = false;
            gameState.gameState = null;
            gameState.isDrawing = false;
            gameState.players = data.players;
            
            clearCanvas();
            updateUI();
            updatePlayersList();
            if (elements.wordToDraw) {
                elements.wordToDraw.textContent = '';
            }
            addChatMessage('system', 'Game has been reset');
        }

        function handleNewRound(data) {
            gameState.gameState = data.gameState;
            gameState.isDrawing = data.drawingPlayerId === gameState.currentPlayer.id;
            
            if (elements.wordToDraw) {
                if (gameState.isDrawing) {
                    elements.wordToDraw.textContent = `Draw: ${data.currentWord}`;
                    addChatMessage('system', 'You are drawing, waiting for guesses...');
                } else {
                    elements.wordToDraw.textContent = 'Guess what is being drawn!';
                    const drawingPlayer = gameState.players.find(p => p.id === data.drawingPlayerId);
                    if (drawingPlayer) {
                        addChatMessage('system', `New round! ${drawingPlayer.name} is now drawing.`);
                    }
                }
            }
            
            clearCanvas();
            updateUI();
            updatePlayersList();
        }

        function handleRoundEnded(data) {
            addChatMessage('system', `Round ended! The word was: ${data.word}`);
        }

        function handleCorrectGuess(data) {
            addChatMessage('correct', `${data.guessingPlayer.name} guessed correctly! +${data.guessingPlayerPoints} points`);
            addChatMessage('system', `${data.drawingPlayer.name} got ${data.drawingPlayerPoints} points`);
            
            if (gameState.gameState) {
                gameState.gameState.scores = data.scores;
                updatePlayersList();
                updateScore();
            }
        }

        function handleTimerUpdate(data) {
            if (elements.timer) {
                elements.timer.textContent = data.timer;
            }
        }

        function handleGameEnded(data) {
            gameState.gameStarted = false;
            showWinnerSection(data.winner, data.winnerScore);
        }

        function handleChatMessage(data) {
            addChatMessage('player', data.message, data.player);
        }

        function handleCanvasUpdated(data) {
            if (gameState.isDrawing || !canvasState.canvasInitialized || !data.canvasData) return;
            
            const img = new Image();
            img.onload = function() {
                const container = elements.drawingCanvas.parentElement;
                const displaySize = Math.min(container.clientWidth, container.clientHeight);
                
                // Clear and redraw at proper display size
                canvasState.ctx.fillStyle = 'white';
                canvasState.ctx.fillRect(0, 0, displaySize, displaySize);
                canvasState.ctx.drawImage(img, 0, 0, displaySize, displaySize);
            };
            img.src = data.canvasData;
        }

        function handleError(data) {
            alert(data.message);
        }

        function handleLeftRoom() {
            showMainMenu();
            gameState.socket.emit('get_rooms', {});
        }

        // UI functions
        function showGameArea() {
            
            // Always clean up before showing game area
            cleanupPreviousRoom();

            if (elements.mainMenu) elements.mainMenu.classList.add('hidden');
            if (elements.gameArea) elements.gameArea.classList.remove('hidden');
            if (elements.winnerSection) elements.winnerSection.classList.add('hidden');
            setupCanvas();
        }

        function showMainMenu() {
            if (elements.mainMenu) elements.mainMenu.classList.remove('hidden');
            if (elements.gameArea) elements.gameArea.classList.add('hidden');
            if (elements.winnerSection) elements.winnerSection.classList.add('hidden');
            
            gameState.currentRoom = null;
            gameState.currentPlayer = null;
            gameState.players = [];
            gameState.isHost = false;
            gameState.gameStarted = false;
            gameState.isDrawing = false;
            gameState.selectedRoomId = null;
        }

        function showWinnerSection(winner, score) {
            if (elements.congratulationsText) {
                elements.congratulationsText.textContent = `Congrats ${winner.name}!`;
            }
            if (elements.winnerMessage) {
                if(typeof score === 'number') {
                    elements.winnerMessage.textContent = `You won the game with ${score} points!`;
                }
                else {
                    elements.winnerMessage.textContent = score;
                }
                
            }
            if (elements.gameArea) elements.gameArea.classList.add('hidden');
            if (elements.winnerSection) elements.winnerSection.classList.remove('hidden');
        }

        function updatePlayersList() {
            if (!elements.playersList) return;
            
            const playersList = elements.playersList;
            playersList.innerHTML = '';
            
            gameState.players.forEach(player => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player';
                
                if (player.id === gameState.currentPlayer.id) {
                    playerDiv.classList.add('current');
                }
                
                if (gameState.gameState && gameState.gameState.drawingPlayerId === player.id) {
                    playerDiv.classList.add('drawing');
                }
                
                if (player.isHost) {
                    playerDiv.classList.add('host');
                }
                else {
                    playerDiv.classList.add('guest');
                }
                
                const score = gameState.gameState ? gameState.gameState.scores[player.id] || 0 : 0;
                
                playerDiv.innerHTML = `
                    <span>${player.name}</span>
                    <span>${score} points</span>
                `;
                
                playersList.appendChild(playerDiv);
            });
        }

        function updateScore() {
            if (elements.yourScore && gameState.gameState && gameState.currentPlayer) {
                const score = gameState.gameState.scores[gameState.currentPlayer.id] || 0;
                elements.yourScore.textContent = `Your score: ${score}`;
            }
        }

        function updateRoomsList(rooms) {
            if (!elements.roomsList) return;
            
            const roomsList = elements.roomsList;
            let noRoomsMessage = document.getElementById('noRoomsMessage');
            
            if (!noRoomsMessage) {
                noRoomsMessage = document.createElement('div');
                noRoomsMessage.id = 'noRoomsMessage';
                noRoomsMessage.className = 'no-rooms';
                noRoomsMessage.innerHTML = `
                    <div style="font-size: 1.2rem; margin-bottom: 10px; color: #6c757d;">ðŸŽ¨ No rooms available</div>
                    <div style="font-size: 0.9rem; color: #8fa0ad;">
                        Create a new room to start playing with friends!
                    </div>
                `;
                roomsList.appendChild(noRoomsMessage);
            }
            
            const roomItems = roomsList.querySelectorAll('.room-item');
            roomItems.forEach(room => room.remove());
            
            if (!rooms || rooms.length === 0) {
                noRoomsMessage.style.display = 'block';
            } else {
                noRoomsMessage.style.display = 'none';
                
                rooms.forEach(room => {
                    const roomDiv = document.createElement('div');
                    roomDiv.className = 'room-item';
                    
                    const statusText = room.status === 'waiting' ? 'Waiting for players' : 'Game in progress';
                    const statusClass = room.status === 'waiting' ? 'status-waiting' : 'status-playing';
                    const languageText = room.language === 'sv' ? 'Swedish' : 'English';
                    
                    roomDiv.innerHTML = `
                        <div class="room-info">
                            <div class="room-name">${room.name}</div>
                            <div class="room-details">
                                ${room.playerCount}/${room.maxPlayers} players â€¢ 
                                Host: ${room.host}
                                <span class="room-status ${statusClass}">${statusText}</span>
                            </div>
                            <div class="room-language">Language: ${languageText}</div>
                        </div>
                        <div class="room-actions">
                            <button class="btn-join" onclick="showJoinModal('${room.id}')">Join</button>
                        </div>
                    `;
                    
                    roomsList.appendChild(roomDiv);
                });
            }
        }

        function updateRoomStatistics(statistics) {
            const statsContainer = elements.roomStatistics;
            if (!statsContainer) return;
            
            statsContainer.style.display = 'block';
            
            const statItems = statsContainer.querySelectorAll('.stat-item');
            statItems.forEach((item, index) => {
                const statValue = item.querySelector('.stat-value');
                const statLabel = item.querySelector('.stat-label');
                
                if (statValue && statLabel) {
                    const statType = statLabel.textContent.toLowerCase();
                    
                    let value = 0;
                    switch (statType) {
                        case 'total rooms': value = statistics.total || 0; break;
                        case 'waiting': value = statistics.waiting || 0; break;
                        case 'playing': value = statistics.playing || 0; break;
                        case 'finished': value = statistics.finished || 0; break;
                    }
                    
                    statValue.textContent = value;
                    statValue.style.transform = 'scale(1.1)';
                    setTimeout(() => {
                        statValue.style.transform = 'scale(1)';
                    }, 300);
                }
            });
        }

        function updateUI() {
            if (elements.startGameBtn) {
                const isGameFinished = gameState.currentRoom && gameState.currentRoom.status === 'finished';
                elements.startGameBtn.disabled = !gameState.isHost || gameState.gameStarted || isGameFinished;
                
                if (isGameFinished) {
                    elements.startGameBtn.textContent = 'Game Finished';
                } else if (gameState.gameStarted) {
                    elements.startGameBtn.textContent = 'Game in Progress';
                } else {
                    elements.startGameBtn.textContent = 'Start Game';
                }
            }

            if (elements.leaveRoomBtn) {
                elements.leaveRoomBtn.disabled = false;
                if (gameState.currentRoom && gameState.currentRoom.status === 'finished') {
                    elements.leaveRoomBtn.textContent = 'Return to Lobby';
                } else {
                    elements.leaveRoomBtn.textContent = 'Leave Room';
                }
            }
            
            if (elements.roomInfo && gameState.currentRoom) {
                const languageText = gameState.currentLanguage === 'sv' ? 'Swedish' : 'English';
                const statusText = gameState.currentRoom.status === 'finished' ? ' (Finished)' : '';
                elements.roomInfo.textContent = `Room: ${gameState.currentRoom.name} (${languageText})${statusText}`;
            }
            
            if (elements.drawingCanvas) {
                elements.drawingCanvas.style.cursor = gameState.isDrawing ? 'crosshair' : 'not-allowed';
                elements.drawingCanvas.style.opacity = gameState.isDrawing ? '1' : '0.7';
            }
            
            if (elements.messageInput) {
                const isGameFinished = gameState.currentRoom && gameState.currentRoom.status === 'finished';
                elements.messageInput.disabled = gameState.isDrawing || isGameFinished;
                if (isGameFinished) {
                    elements.messageInput.placeholder = 'Game has ended';
                } else if (gameState.isDrawing) {
                    elements.messageInput.placeholder = 'You are drawing, waiting for guesses...';
                } else {
                    elements.messageInput.placeholder = 'Type your guess here...';
                }
            }
            
            if (elements.sendMessageBtn) {
                const isGameFinished = gameState.currentRoom && gameState.currentRoom.status === 'finished';
                elements.sendMessageBtn.disabled = gameState.isDrawing || isGameFinished;
            }
            
            updateScore();
        }

        // Modal functions
        function showJoinModal(roomId) {
            gameState.selectedRoomId = roomId;
            if (elements.joinPlayerName) elements.joinPlayerName.value = '';
            if (elements.joinRoomModal) elements.joinRoomModal.classList.add('show');
        }

        function hideJoinModal() {
            if (elements.joinRoomModal) elements.joinRoomModal.classList.remove('show');
            gameState.selectedRoomId = null;
        }

        function confirmJoinRoom() {
            const playerName = elements.joinPlayerName ? elements.joinPlayerName.value.trim() : '';
            if (!playerName) {
                alert('Name is required');
                return;
            }
            
            gameState.socket.emit('join_room', {
                roomId: gameState.selectedRoomId,
                playerName: playerName
            });
        
            hideJoinModal();
        }

        // Game actions
        function createRoom() {
            const playerName = elements.createPlayerName ? elements.createPlayerName.value.trim() : '';
            const roomName = elements.roomName ? elements.roomName.value.trim() : `${playerName}'s room`;
            const language = elements.roomLanguage ? elements.roomLanguage.value : 'en';
            
            if (!playerName) {
                alert('Name is required');
                return;
            }
            
            gameState.socket.emit('create_room', {
                playerName: playerName,
                roomName: roomName,
                language: language
            });
        }

        function startGame() {
            gameState.socket.emit('start_game', {});
        }

        function leaveRoom() {
            gameState.socket.emit('leave_room', {});
        }

        function sendMessage() {
            const message = elements.messageInput ? elements.messageInput.value.trim() : '';
            if (message) {
                gameState.socket.emit('send_message', { message: message });
                if (elements.messageInput) elements.messageInput.value = '';
            }
        }

        function backToLobby() {
            leaveRoom();
        }

        function addChatMessage(type, message, player = null) {
            if (!elements.chatMessages) return;
            
            const chatMessages = elements.chatMessages;
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            let messageText = message;
            if (type === 'player' && player) {
                messageText = `${player.name}: ${message}`;
            } else if (type === 'system' || type === 'game-ended') {
                messageText = message;
            }
            
            messageDiv.textContent = messageText;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Make functions available globally
        window.showJoinModal = showJoinModal;
        window.confirmJoinRoom = confirmJoinRoom;

        function cleanupPreviousRoom() {

            // Clear all UI elements
            const elementsToClear = {
                chatMessages: '',
                playersList: '',
                wordToDraw: '',
                roomInfo: '',
                timer: '60',
                yourScore: 'Your score: 0'
            };
            
            Object.keys(elementsToClear).forEach(elementId => {
                if (elements[elementId]) {
                    elements[elementId].innerHTML = elementsToClear[elementId];
                }
            });
            
            // Clear input fields
            if (elements.messageInput) {
                elements.messageInput.value = '';
                elements.messageInput.disabled = false;
            }
            
            // Reset canvas
            if (canvasState.ctx && canvasState.canvasInitialized && elements.drawingCanvas) {
                const container = elements.drawingCanvas.parentElement;
                if (container) {
                    const displaySize = Math.min(container.clientWidth, container.clientHeight);
                    canvasState.ctx.fillStyle = 'white';
                    canvasState.ctx.fillRect(0, 0, displaySize, displaySize);
                }
            }
            
            // Reset game state
            const resetState = {
                gameStarted: false,
                isDrawing: false,
                gameState: null
            };
            
            Object.assign(gameState, resetState);
            
            // Update UI to reflect clean state
            updateUI();
        }

        // Initialize the game when page has been loaded
        window.addEventListener('load', init);
    </script>
</body>
</html>